package it.unitn.LODE.services;

import it.unitn.LODE.Controllers.LectureController;
import it.unitn.LODE.MP.constants.LODEConstants;
import it.unitn.LODE.MP.utils.CorrectPathFinder;
import it.unitn.LODE.MP.utils.SystemProps;
import it.unitn.LODE.Models.Lecture;
import it.unitn.LODE.Models.ProgramState;
import it.unitn.LODE.gui.FileTree.ArchiveRetriever;
import it.unitn.LODE.gui.InspectorWindow;
import it.unitn.LODE.gui.ProgressBar;
import it.unitn.LODE.services.accessibility.PostProcess4Accessibility;
import it.unitn.LODE.services.packaging.Data;
import it.unitn.LODE.utils.Messanger;
import it.unitn.LODE.utils.RunnableProcess;
import java.io.File;
import java.io.IOException;
import java.util.Date;
import javax.swing.JOptionPane;

/**
 *
 * @author ronchet
 */
public class PostProducer extends PostProducerIF {
    //inherited protected FileSystemManager fileSystemManager;

    Messanger m = Messanger.getInstance();
    // ========== SOLITON PATTERN ==============================================
    static PostProducer subclass_instance = null;

    public synchronized static PostProducer getInstance() {
        if (subclass_instance == null) {
            subclass_instance = new PostProducer();
        }
        return subclass_instance;
    }

    private PostProducer() {
    }

    /**
     * Do the whole postprocessing - first compress video, then create
     * distribuion structure
     *
     * @param videoPath path of the file to be created
     * @return
     */
    @Override
    public final boolean convertVideo(final String videoPath) {
        return _compressVideo(videoPath, true, true, true, false);
    }

    @Override
    public final Thread convertAllLectures() {
        Thread t = new Thread() {

            @Override
            public void run() {
                convertVideo(ArchiveRetriever.getAllLectures());
            }
        };
        t.start();
        return t;
    }
    // assumes f to be a course directory

    @Override
    public final Thread convertAllLecturesInCourse(final File f) {
        Thread t = new Thread() {

            @Override
            public void run() {
                convertVideo(ArchiveRetriever.getAllLecturesInCourse(f));
            }
        };
        t.start();
        return t;
    }

    @Override
    public final boolean convertVideo(File[] fv) {
        boolean retval = true;
        LectureController lc = LectureController.getInstance();
        boolean postprocessingAFile = false;
        Lecture l = null;
        /*
         * for (File f:fv){ synchronized(instance) { if (postprocessingAFile) {
         * try { // this lock will be released at the end of createDistribution
         * System.out.println((new Date())+" Starting to wait "); wait();
         * System.out.println((new Date())+" Finished waiting "); } catch
         * (InterruptedException ex) {
         * ex.printStackTrace(Messanger.getInstance().getLogger()); } }
         * lc.setLectureFromPath(f.getAbsolutePath());
         * l=ProgramState.getCurrentLecture(); if (l.hasVideo() && !
         * l.hasBeenPostProcessed()) { postprocessingAFile=true;
         * System.out.println((new Date())+" Starting to wait - processing
         * lecture "+l.getLectureName()); String
         * videoPath=l.getAcquisitionPath()+LODEConstants.FS+LODEConstants.MOVIE_FILE+"0";
         * /// THIS SHOULD BE FIXED
         * retval=retval&&compressVideo(videoPath,false,true,false,true); } else
         * { postprocessingAFile=false; System.out.println((new Date())+"
         * Lecture "+l.getLectureName()+" does not need postprocessing"); } }
         */
        ProgramState programState = ProgramState.getInstance();
        for (File f : fv) {
            lc.setLectureFromPath(f.getAbsolutePath());
            l = programState.getCurrentLecture();
            if (!(l.hasVideo() && !l.hasBeenPostProcessed())) {
                System.out.println((new Date()) + " Lecture " + l.getLectureName() + " does not need postprocessing");
            } else {
                System.out.println((new Date()) + " Starting to wait - processing lecture " + l.getLectureName());
                String videoPath = l.getAcquisitionPath() + File.separator + LODEConstants.MOVIE_FILE + "0" + LODEConstants.MOVIE_EXTENSION; /// TODO - THIS SHOULD BE FIXED
                retval = retval && _compressVideo(videoPath, false, true, false, true);
                final PostProducer token = (PostProducer) instance;
                synchronized (token) {
                    try {
                        // this lock will be released at the end of createDistribution
                        // that is launched in another thread generated by compressVideo above.
                        System.out.println((new Date()) + " Starting to wait for postprocessing to be completed");
                        token.wait();
                        System.out.println((new Date()) + " Finished waiting - postprocessing is complete");
                    } catch (InterruptedException ex) {
                        ex.printStackTrace(Messanger.getInstance().getLogger());
                    }
                }
            }
        }
        return retval;
    }

    /**
     *
     * @param videoPath path of the file to be created
     * @param createDistribution if true the whole distribution ic created after
     * compression, else the process stops right after the video compression
     * @return
     */
    private boolean _compressVideo(final String videoPath,
            final boolean selectResolution,
            final boolean createDistribution,
            final boolean showFinalDialog,
            final boolean synchronous) {
        System.err.println((new Date()) + "starting execution on " + videoPath);

        //========== XUGGLE IMPLEMENTATION - start
       /*
        if (SystemProps.IS_OS_WINDOWS) {
            new MultiPlatformVideoConverter().convert(videoPath, selectResolution, createDistribution, showFinalDialog, synchronous);
            _addFlvMetadata(videoPath + ".flv", createDistribution, showFinalDialog);
        }
        */
        //========== XUGGLE IMPLEMENTATION - end

        //========== FFMPEG IMPLEMENTATION - start
        //if (SystemProps.IS_OS_MAC) {
            String command[] = _FFMPEG_compressVideo(videoPath, videoPath + ".flv");

            //command[13] = "640x480"; // this is the default resolution
            if (selectResolution) {
                int response = JOptionPane.showOptionDialog(null,
                        "At which resolution should the video be compressed? \n\n"
                        + "HIGH (640x480 - DEFAULT) implies larger video file - faster postprocessing - \n"
                        + "LOW (320x240) means smaller video file - slower postprocessing",
                        "Choose the resolution",
                        JOptionPane.YES_OPTION,
                        JOptionPane.QUESTION_MESSAGE,
                        LODEConstants.ICON_LODE,
                        new String[]{
                            "- LOW -",
                            "- HIGH -"
                        },
                        null);
                if (response == 0) {
                    command[13] = "320x240";
                }
            }
            m.w("Compressing video at " + command[15], LODEConstants.MSG_GENERIC);
            //command[2] = videoPath;
            //command[33] = videoPath + ".flv";
            final Process p = RunnableProcess.launch(command, true, false);
            final ProcessLogger logger = ProcessLogger.getProcessLogger(p);
            final ProgressBar pb = ProgressBar.showIndeterminateProgressBar("Please wait - executing video conversion");
            ////ProcessWaiter waitForProcess=new ProcessWaiter(p,"ffmpeg pass is complete");
            Thread waitForProcess = new Thread(new Runnable() {

                @Override
                public void run() {
                    try {
                        p.waitFor();
                    } catch (InterruptedException ex) {
                        ex.printStackTrace(m.getLogger());
                        m.w("Error while writing output of Process " + p.toString(), LODEConstants.MSG_ERROR);
                    }
                    pb.closeWindow();
                    //logger.setVisible(false);
                    _addFlvMetadata(videoPath + ".flv", createDistribution, showFinalDialog);
                }
            ;
            });
        waitForProcess.start();
            System.out.println("end execution" + (new Date()));
        //}
        //========== FFMPEG IMPLEMENTATION - end

        return true;
    }
    /*
     * It seems the script inside
     * /Applications/ffmpegX.app//Contents/Resources/flvtool2 points to
     * /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby while
     * on my system (10.4.11), and maybe yours as well, it should point to
     * /usr/bin/ruby because that's where ruby resides on my system. You can
     * edit that in any text editor. (I did it with BBEdit.) The "bad
     * interpreter: No such file or directory"-error no longer appears in the
     * log. This fixes the metadata being correctly added to the .flv file. With
     * the wrong path in the script, you should get a valid .flv file without
     * the metadata, just like the previous version of ffmpegX.
     */ 

    private boolean _addFlvMetadata(String fileName, final boolean createDistribution, final boolean showFinalDialog) {
        String command[] = {
            LODEConstants.FLVTOOL2_PATH, //CorrectPathFinder.getJarPath(LODEConstants.FLVTOOL2_PATH),
            "-UP",
            "FLV_FILE"
        };
        command[2] = fileName;
        final Process p = RunnableProcess.launch(command, true, false);
        final ProcessLogger logger = ProcessLogger.getProcessLogger(p);
        final ProgressBar pb = ProgressBar.showIndeterminateProgressBar("Please wait - adding metadata");
        ////ProcessWaiter waitForProcess=new ProcessWaiter(p,"ffmpeg pass is complete");

        Thread waitForProcess = new Thread(new Runnable() {

            @Override
            public void run() {
                try {
                    p.waitFor();
                } catch (InterruptedException ex) {
                    ex.printStackTrace(m.getLogger());
                    m.w("Error while writing output of Process " + p.toString(), LODEConstants.MSG_ERROR);
                }
                pb.closeWindow();
                if (createDistribution) {
                    createDistribution(ProgramState.getInstance().getCurrentLecture(), showFinalDialog);
                }
            }
        ;
        });
        waitForProcess.start();
        return true;

    }

    @Override
    public void makeItAccessible(Lecture lecture) {
        PostProcess4Accessibility pp4a = new PostProcess4Accessibility(lecture);
        pp4a.createLectureJS();
        pp4a.switchOffLine();
    }

    @Override
    public final void createDistribution(Lecture lecture) {
        createDistribution(lecture, true);
    }

    @Override
    public final void createDistribution(Lecture lecture, boolean showFinalDialog) {
        File destinationDir = null;
        File sourceDir = null;
        String distributionPath = lecture.getDistributionPath();
        String acquisitionPath = lecture.getAcquisitionPath();
        // throw away existing distribution dir
        File distributionDir = new File(distributionPath);
        if (distributionDir.exists()) {
            fileSystemManager.recursiveDelete(distributionDir);
        }
        // create new empty distribution dir
        fileSystemManager.createFolder(distributionDir);
        m.w("Distribution path " + distributionPath + " has been created.", LODEConstants.MSG_LOG);
        m.log("Distribution path " + distributionPath + " has been created.");
        String templatePath = CorrectPathFinder.getPath(LODEConstants.TEMPLATE_PREFIX);
        /*
         * // get the path for the template (i.e. the standard distribution
         * files) String
         * templatePath=PostProducer.class.getResource(LODEConstants.TEMPLATE_PREFIX).getFile();
         * if (templatePath!=null && templatePath.startsWith("file:")) { // in
         * the distribution, filename is file:/path/.../Java/LODE.jar... //
         * throw away head and tail! templatePath=templatePath.substring(5,
         * templatePath.indexOf("/Java/LODE.jar"))+LODEConstants.TEMPLATE_PREFIX;
         * } else templatePath =
         * PostProducer.class.getResource(LODEConstants.TEMPLATE_PREFIX+LODEConstants.FS).getFile();
         */

        sourceDir = new File(templatePath);
        if (!sourceDir.exists()) {
            m.w(templatePath + " does not exist!", LODEConstants.MSG_ERROR);
            m.log(templatePath + " does not exist!");
        }
        // copy template files into distribution dir
        try {
            fileSystemManager.copyFiles(distributionDir, sourceDir);
        } catch (IOException ex) {
            m.w("CANNOT COPY! " + templatePath + " -> " + distributionDir, LODEConstants.MSG_ERROR);
            m.log("CANNOT COPY! " + templatePath + " -> " + distributionDir);
            ex.printStackTrace(m.getLogger());
        }
        if (lecture.hasSlides()) {
            // copy images of slides into distribution dir
            try {
                destinationDir = new File(distributionDir + LODEConstants.DISTRIBUTION_IMG_SUBDIR);
                sourceDir = new File(acquisitionPath + LODEConstants.ACQUISITION_IMG_SUBDIR);
                fileSystemManager.copyFiles(destinationDir, sourceDir);
            } catch (IOException ex) {
                m.w("CANNOT COPY! " + sourceDir + " -> " + distributionDir, LODEConstants.MSG_ERROR);
                m.log("CANNOT COPY! " + sourceDir + " -> " + distributionDir);
                ex.printStackTrace(m.getLogger());
            }
        };
        //pp.switchOnLine();
        // copy video into distribution dir
        String destinationPath = distributionDir + File.separator + "content/movie.mp4";
        String originPath = acquisitionPath + File.separator + LODEConstants.MOVIE_FILE + "0" + LODEConstants.MOVIE_EXTENSION;
        try {
            fileSystemManager.copyFiles(new File(destinationPath), new File(originPath));
        } catch (IOException ex) {
            fileSystemManager.cannotCopyMessage(ex, destinationPath, originPath);
        }
        destinationPath = distributionDir + File.separator + "content/movie.flv";
        originPath = acquisitionPath + File.separator + LODEConstants.MOVIE_FILE + "0" + LODEConstants.MOVIE_EXTENSION + ".flv";
        try {
            fileSystemManager.copyFiles(new File(destinationPath), new File(originPath));
        } catch (IOException ex) {
            fileSystemManager.cannotCopyMessage(ex, destinationPath, originPath);
        }


        /*
         * String
         * command[]={"cp",acquisitionPath+LODEConstants.FS+LODEConstants.MOVIE_FILE+"0"+LODEConstants.MOVIE_EXTENSION+".flv",iTunesDistributionDir+LODEConstants.FS+"content/movie.flv"};
         * final Process p=RunnableProcess.launch(command, false, false);
         * //final ProgressBar
         * pb=ProgressBar.showIndeterminateProgressBar("Please wait - executing
         * postprocessing"); ProcessWaiter pw=new ProcessWaiter(p,"movie
         * copied");
         */
        // create the main info file (data.xml) and copy it into distribution dir
        Data dataXml = new Data(lecture, true);
        File dataXmlFile = new File(lecture.getAcquisitionPath() + File.separator + LODEConstants.DATA_XML);
        if (dataXmlFile.exists()) {
            dataXmlFile.delete();
        }
        dataXml.persist(dataXmlFile);
        /*
         * pw.start(); String
         * command1[]={"cp",dataXmlFile.getAbsolutePath(),iTunesDistributionDir+LODEConstants.FS+"content"+LODEConstants.FS+LODEConstants.DATA_XML};
         * final Process p1=RunnableProcess.launch(command1, false, false);
         * ProcessWaiter pw1=new ProcessWaiter(p1,"data.xml copied");
         * pw1.start();
         *
         */
        destinationPath = distributionDir + File.separator + "content" + File.separator + LODEConstants.DATA_XML;
        originPath = dataXmlFile.getAbsolutePath();
        try {
            fileSystemManager.copyFiles(new File(destinationPath), new File(originPath));
        } catch (IOException ex) {
            fileSystemManager.cannotCopyMessage(ex, destinationPath, originPath);
        }
        // prepare Accessibility
        PostProcess4Accessibility pp = new PostProcess4Accessibility(lecture);
        pp.createLectureJS();
        // update lecture state
        lecture.setHasBeenPostProcessed(true);
        InspectorWindow.getInstance().update();
        lecture.persist(new File(lecture.getAcquisitionPath() + File.separator + LODEConstants.SERIALIZED_LECTURE));
        if (showFinalDialog) {
            // allow the user immediately viewing the postprocessed movie!
            int choice = JOptionPane.showOptionDialog(null,
                    "<HTML><center>Postprocessing complete.<BR><BR>"
                    + "You can now find the postprocessed lecture in<BR>"
                    + "<B>" + distributionDir + "</B></center><br></HTML>",
                    "Postprocessing complete",
                    JOptionPane.WARNING_MESSAGE,
                    JOptionPane.DEFAULT_OPTION,
                    LODEConstants.ICON_LODE,
                    new Object[]{"Thanks, do no show it", "Show it in a browser window"},
                    null);
            if (choice == 1) {
                fileSystemManager.showInBrowser("file://" + distributionDir + "/index.html", null);
            }
        }
        // if running in a sequence, let the next postprocessing start
        final PostProducer token = (PostProducer) instance;
        synchronized (token) {
            token.notify();
        }
    }

    @Override
    public final void postProcessAllRemotely() {
        Scripter s = new Scripter();
        s.remoteLaunch("java -jar /Applications/LODE.app/Contents/Resources/Java/LODE.jar HEADLESS POSTPROCESS_ALL", false);
    }
    //==========================================================================
    @Override
        public void createItunesuDistribution(Lecture lecture) { //Antonio
        PostProducer_iTunesU.getInstance().createItunesuDistribution(lecture);
    }
    @Override
        public final boolean convertVideo4Itunesu(Lecture lec) { //Antonio
        return PostProducer_iTunesU.getInstance().convertVideo4Itunesu(lec);            
        }
    @Override
        public void createItunesuDistribution(Lecture lecture, boolean showFinalDialog) { //Antonio
        PostProducer_iTunesU.getInstance().createItunesuDistribution(lecture, showFinalDialog);
        }
    
        private String[] _FFMPEG_compressVideo(String inputFile, String outputFile) {
        //String FFMPEG_COMMAND=CorrectPathFinder.getJarPath("/Resources")+"\\ffmpeg.exe";
        String FFMPEG_COMMAND=LODEConstants.FFMPEG_COMMAND;
        String cmd[] = {
            FFMPEG_COMMAND, //0
            "-i", inputFile, //1-2 -i: input file name
            "-y", //3 -y:Overwrite output files
            //"-map","0.0:0.0", //
            "-f", "flv", //4-5 -f: force format
            "-vcodec", "flv", //6-7 -vcoded: Force video codec to codec
            "-b", "200", //8-9 -b: Set the video bitrate in bit/s (default = 200 kb/s)
            "-aspect", "4:3", //10-11 -aspect: Set aspect ratio (4:3, 16:9 or 1.3333, 1.7777)
            "-s", "640x480",// 12-13   "320x240", -s: Set frame size. The format is wxh
            "-r", "25", //14-15 -r: Set frame rate (Hz value, fraction or abbreviation), (default = 25).
            "-g", "24", //16-17 -g: Set the group of pictures size. See http://www.technogumbo.com/2008/08/ffmpeg-setting-keyframes/
            //"-me", "epzs", //18-19
            "", "", //18-19    -me (should be -me_method ?): Set motion estimation method to method. Default is epzs.
            "-qmin", "2", //20-21 -qmin: minimum video quantizer scale
            "-qmax", "15", //22-23 -qmax: maximum video quantizer scale
            "-acodec", "mp3", //24-25 -acoded: Force audio codec to codec
            "-ab", "56", //26-27 -ab: set the audio bitrate in bit/s (default = 64k)
            "-ar", "22050", //28-29 -ar: Set the audio sampling frequency (default = 44100 Hz)
            "-ac", "2", //30-31 -ac: Set the number of audio channels (default = 1)
            //"-map","0.1:0.1",  //
            "-benchmark", //32 -benchmank: Show benchmarking information at the end of an encode. Shows CPU time used and maximum memory consumption.
            outputFile //33
        };
        printcmd(cmd);
        return cmd;
    }
        
    private void printcmd(String a[]) {
        for (int k = 0; k < a.length; k++) {
            System.out.print(a[k] + " ");
        }
        System.out.println(a);
        System.out.flush();
    }
}
