package it.unitn.LODE.itunesuMetadata.gui;

import it.unitn.LODE.Models.StorableAsXML;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.Set;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextArea;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableColumn;


public abstract class TablePanel extends javax.swing.JPanel{
    protected StorableAsXML rss;
    protected JTextArea output;
    protected String newline = "\n";
    protected HashMap<String,String>  propsMap=null;
    protected String filename="rss.xml";



    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    public void initComponentsAndShow() {
        ///final HashMap hm = new HashMap();
        // populate model starting from propsMap
        ///hm.putAll(propsMap);
        ///final MyTableModel model = new MyTableModel(hm);
        final MyTableModel model = new MyTableModel(propsMap);
        JTable table = new JTable(model);
        TableColumn column = table.getColumnModel().getColumn(0);
        column.setPreferredWidth(150);
        column.setMaxWidth(200);
        JScrollPane scrollPane = new JScrollPane(table);
        table.setFillsViewportHeight(true);
        this.setOpaque(true);
        this.setLayout(new BorderLayout());
        this.add(scrollPane, BorderLayout.NORTH);
        JButton generateButton = new JButton("genera XML");
        this.add(generateButton, BorderLayout.SOUTH);
        generateButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                ///propsMap.putAll(hm);
                rss.update(); //copy the values into the xml mapper
                rss.persist(new File(filename));
                model.print();
                Set<Entry<String, String>> values=propsMap.entrySet();
                for (Entry<String, String> x:values) {
                    System.out.println("==>"+x.getKey()+" - "+x.getValue());
                }
            }
        });
        JFrame f = new JFrame();
        Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();
        f.setSize(dim.width-100, 500);
        f.setContentPane(this);
        //f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        //f.pack();
        f.setVisible(true);
    }

    //===================================

    class MyTableModel extends AbstractTableModel {
        String[] columnNames = {"TAG",
                        "Valore"};
        HashMap hm=null;
        int n=0;
        Object[][] data=null;

        MyTableModel(HashMap hm){
            this.hm=hm;
            n=hm.size();
            data= new Object[n][2];
            Set keys=hm.keySet();
            Iterator iter=keys.iterator();
            int i=0;
            while (iter.hasNext()) {
                Object o=iter.next();
                data[i][0]=o;
                data[i][1]=hm.get(o);
                i++;
            }
        }

        public void writeHashMap(){
            hm=new HashMap();
            for (Object[] s:data) {
                hm.put(data[0], data[1]);
            }
        }

        public int getColumnCount() {
            return columnNames.length;
        }

        public int getRowCount() {
            return data.length;
        }

        public String getColumnName(int col) {
            return columnNames[col];
        }

        public Object getValueAt(int row, int col) {
            return data[row][col];
        }

        /*
         * JTable uses this method to determine the default renderer/
         * editor for each cell.  If we didn't implement this method,
         * then the last column would contain text ("true"/"false"),
         * rather than a check box.
         */
        public Class getColumnClass(int c) {
            return getValueAt(0, c).getClass();
        }

        /*
         * Don't need to implement this method unless your table's
         * editable.
         */
        public boolean isCellEditable(int row, int col) {
            //Note that the data/cell address is constant,
            //no matter where the cell appears onscreen.
            if (col < 1) {
                return false;
            } else {
                return true;
            }
        }

        /*
         * Don't need to implement this method unless your table's
         * data can change.
         */
        public void setValueAt(Object value, int row, int col) {
            data[row][col] = value;
            fireTableCellUpdated(row, col);
            hm.put(data[row][0], value);
        }

        public void print(){
            for (Object[] s:data) {
                System.out.println((String)s[0]+"="+(String)s[1]);
            }
        }
   }
}
